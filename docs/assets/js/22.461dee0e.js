(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{432:function(t,e,r){"use strict";r.r(e);var s=r(2),a=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"一、token分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、token分类"}},[t._v("#")]),t._v(" 一、token分类")]),t._v(" "),e("p",[t._v("1.普通令牌的作用：唯一标识存贮在数据库或"),e("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("内存"),e("OutboundLink")],1),t._v("中的用户信息，在认证时，SpringSecurity拿着普通令牌去数据库中查询用户信息使用\n2.jwt令牌的作用：jwt令牌中本身存储着用户信息，在认证时，SpringSecurity从jwt令牌中解析出用户信息即可，不需要借助数据库等进行存储")]),t._v(" "),e("h3",{attrs:{id:"_1-普通令牌"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-普通令牌"}},[t._v("#")]),t._v(" 1. 普通令牌")]),t._v(" "),e("p",[t._v("普通令牌是SpringSecurityOauth2给客户端颁发的一个无含义的令牌，在令牌发布时，SpringSecurityOauth2将用户信息存储到程序指定的存储位置，并用普通令牌唯一标识这个存储信息，当用户再次携带令牌访问时，SpringSecurityOauth2会根据令牌查询用户信息，进而实现权限角色的限制。")]),t._v(" "),e("p",[t._v("普通令牌需要一个存储用户信息的地方，这个地方可以内存，也可以是数据库（Redis、Mysql）。")]),t._v(" "),e("p",[t._v("基于数据库存储（以Redis为例）")]),t._v(" "),e("p",[t._v("①基于Redis存储用户信息的方式，认证服务器将用户信息存储到指定的Redis数据库中\n②当资源服务获取到access_token时，会到Redis中获取用户信息\n③在微服务场景下适用")]),t._v(" "),e("h3",{attrs:{id:"_2-jwt令牌"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-jwt令牌"}},[t._v("#")]),t._v(" 2. JWT令牌")]),t._v(" "),e("p",[t._v("jwt令牌的方式就无需数据库的介入，jwt令牌中就包含着用户的信息，SpringSecurityOauth在发布令牌时，会将用户信息放入JWT令牌中，用户拿着JWT令牌时，SpringSecurityOauth从中获取到用户信息，实现用户权限的控制。")]),t._v(" "),e("p",[t._v("jwt不需要后端进行存储。\n①基于JWT令牌的认证服务器，用户信息存储到令牌中\n②当资源服务获取到access_token后，会解析这个jwt类型的access_token，从中会获取到用户信息\n③微服务场景下也不适用")]),t._v(" "),e("h2",{attrs:{id:"二、应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、应用场景"}},[t._v("#")]),t._v(" 二、应用场景")]),t._v(" "),e("h3",{attrs:{id:"_1-根据权限是否要求严格角度判断"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-根据权限是否要求严格角度判断"}},[t._v("#")]),t._v(" 1. 根据权限是否要求严格角度判断")]),t._v(" "),e("p",[t._v("流行的jwt有一个设计上的缺陷，他通过密文传输用户信息，那么服务器在这种基础结构下是无法做到关闭用户登陆授权的操作，如果用户的jwt密文被偷窃，那么黑客就能以用户身份登陆，并且即使知道密文丢失，也无法关闭被偷窃的jwt密文。为了应对这一问题，可以使用jwt内部验证有效期和jwt黑名单模式，但是有效期始终无法做到及时停止jwt授权，这是一个治标不治本的方法。而jwt黑名单模式，则需要数据库或内存存储黑名单，那么，这实际上违背了jwt的免数据库设计原则。")]),t._v(" "),e("p",[t._v("因此，如果严格按照两种模式设计，"),e("strong",[t._v("jwt更适合低安全级别的服务器设计，如普通的博客、阅读器等等")]),t._v("，这种服务允许不严格的登陆授权，即使密文丢失也不会造成用户的严重损失，却能获得较高的服务性能。")]),t._v(" "),e("p",[t._v("token模式，必须配合数据库进行存储和查询，因此性能较低，但token模式却能做到及时的授权关闭，已经登陆授权可见可查，每一次token都会有对应的记录。因此token模式适合较高安全度和用户登陆等信息分析的系统，如"),e("strong",[t._v("政府系统，支付系统等不可能允许高权限的token被偷窃却不能及时关闭授权。")])]),t._v(" "),e("p",[t._v("jwt，适合轻量的系统和权限不严格系统。\ntoken，适合重量系统和权限有严格要求的系统。")])])}),[],!1,null,null,null);e.default=a.exports}}]);